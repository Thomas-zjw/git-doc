

## ARM体系结构(ARMV7-A)

### 1. ARM工作模式和工作状态

1.用户模式:
2.快速中断模式:
3.外部中断模式:
4.SVC模式:
5.中止模式(abort):
6.未定义模式:
7.系统模式:

*注：也可以理解为6种工作模式，其中用户模式和系统模式共用一组寄存器*

除用户模式，其余模式是特权模式；除用户模式和系统模式以外的模式是异常模式。处理器工作模式的改变可以通过软件改变或者外部中断或异常处理改变。

处理器的工作状态包括：

1. ARM状态：执行32位指令集

2. Thumb状态：执行16位指令集

### 2. ARM寄存器

ARM分为[2]类寄存器，通用寄存器和状态寄存器；其中通用寄存器31个，状态寄存器6个。

**能够同时被访问的寄存器是18个，16个通用寄存器和2个状态寄存器**

#### 2.1 通用寄存器 

通用寄存器包括R0~R15，同时分为3类

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200428232733598.png" alt="image-20200428232733598" style="zoom:50%;" />

##### 2.1.1 未分组寄存器

R0~R7，工作在所有模式下，未分组寄存器都指向同一个物理寄存器

##### 2.1.2 分组寄存器

R8 ~ R14，每一次访问的寄存器和处理器的工作模式有关系

对于R8 ~ R12，每个寄存器对应**两个**不同的物理地址；

R13和R14来说，每个寄存器对应6个不同的物理地址，其中用户模式和系统模式共用一组寄存器；另外5个物理寄存器对应5种不同的处理器模式

R13常用作栈指针（SP）；R14常用作程序链接寄存器（LR）

##### 2.1.3 程序寄存器

R15（PC）：指向将要执行的下一条指令

#### 2.2 状态寄存器

CPSR：当前程序状态寄存器（1个）

SPSR：备份程序状态寄存器（5个），用户模式和系统模式下没有该寄存器；当发生异常时，SPSR用于保存CPSR的当前值，从异常退出的时候可以由SPSR来恢复CPSR

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200429000213358.png" alt="image-20200429000213358" style="zoom:50%;" />

##### 2.2.1 条件码标志位

N、Z、C、V均为条件码标志位，他们的内容可以被算术或逻辑运算的结果改变，并且可以决定某条指令是否被执行

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200429193943028.png" alt="image-20200429193943028" style="zoom:80%;" />

##### 2.2.2 控制位

控制位指的是CPSR的低8位；如果处理器处于特权模式，这些位可以由程序更改

1. 中断控制位

   主要包括I、F控制位，用来控制IRQ和FIQ中断，当为1的时候表示禁止中断，当为0的时候表示允许中断

2. T控制位

   主要控制处理器的运行状态，是Thumb还是Arm；当该位为0时，表示运行在Arm状态，当该位为1时，表示运行在Thumb状态

3. 工作模式控制位

   M[4:0]用来**标识或设置**处理器的工作模式

   <img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200429195149218.png" alt="image-20200429195149218" style="zoom:50%;" />

### 3. Arm指令系统

#### 3.1指令和指令格式

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200430224107809.png" alt="image-20200430224107809" style="zoom:60%;" />

Arm指令分为**5**域，

1. [31~28]：条件码域

2. [27~25]：指令编码

3. [19~16]：基地址Rn

4. [15~12]：目标或源寄存器Rd

5. [11~  0]：地址偏移或操作寄存器、操作数


指令格式：

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200430224750010.png" alt="image-20200430224750010" style="zoom:50%;" />

<>中的内容必不可少，{}中的内容可省略

##### 3.1.1指令可选后缀

1. "S" 后缀

   指令执行后CPSR中的条件标志位将被刷新

2. "!"后缀

   指令中的地址表达式中含有"!"，指令执行后，基地址寄存器中的地址值将发生变化：

   **基地址寄存器中的值（指令执行后）= 指令执行前的值 + 地址偏移量**

   *注："!"后缀不能用于R15（PC）的后面*

##### 3.1.2指令的条件执行

当CPSR中条件码被满足的时候，执行指令，否则指令被忽略

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200430234111032.png" alt="image-20200430234111032" style="zoom:50%;" />

#### 3.2Arm指令寻址方式

##### 3.2.1立即数寻址

操作数本省就在指令中给出，例如：MOV R0，#15

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200501000356789.png" alt="image-20200501000356789" style="zoom:50%;" />

##### 3.2.2寄存器寻址

利用寄存器中的数值作为操作数，例如：ADD R0，R1，R2

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200501000323261.png" alt="image-20200501000323261" style="zoom:50%;" />

##### 3.2.3寄存器间接寻址

以寄存器中的值作为操作数的地址，例如：LDR R0，[R4]

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200501000256587.png" alt="image-20200501000256587" style="zoom:50%;" />

##### 3.2.4寄存器位移寻址

操作数由寄存器中的数值做相应的位移得到，位移的方式在指令中以助记符形式给出，

例如：ADD R0，R1，R2，LSL #1

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200501000732584.png" alt="image-20200501000732584" style="zoom:50%;" />

##### 3.2.5基址变址寻址

将寄存器中的内容与指令中给出的地址偏移量相加得到一个操作数的有效地址，

例如：LDR R0，[R1，#4]

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200501001213651.png" alt="image-20200501001213651" style="zoom:50%;" />

##### 3.2.6多寄存器寻址

一条指令可以完成多个寄存器值的传送，最多可传送16个寄存器的值，连续寄存器用"-"，否则用","；

例如：LDMIA R0！，{R1-R4}

<img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200501173405954.png" alt="image-20200501173405954" style="zoom:50%;" />

##### 3.2.7堆栈寻址 （入栈、出栈）

Arm中分别采用LDMFD和STMFD指令来支持出栈和入栈操作，R13栈指针，总是指向栈顶；

例如：STMFD R13！，{R0-R4}

​		   LDMFD R13！，{R0-R4}

#### 4.Arm指令集

##### 4.1 MOV指令

##### 4.2 MVN指令

与MOV指令不同的是，数据在传送之前被按位取反了

示例：MVN R0，R1；	#将R1中的值按位取反，结果存入R0中

##### 4.3 移位操作

1. **LSL：逻辑左移**

   **低位用0来填充**

   <img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200502112857081.png" alt="image-20200502112857081" style="zoom:50%;" />

   例如：MOVS R0，R1，LSL #1

   指令执行前：R0 = 0x00000000，R1 = 0x80000004

   指令执行后：R0 = 0x00000008，R1 = 0x80000004，C条件标志位 = 1

   左移前的最高位送入C位

   <img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200502113606243.png" alt="image-20200502113606243" style="zoom:50%;" />

2. **LSR：逻辑右移**

   **高位用0来填充**

   例如：MOVS R0，R1，LSR #1

   指令执行前：R0 = 0xFFFFFFFF，R1 = 0x00000001

   指令执行后：R0 = 0x00000000，R1 = 0x00000001，C条件标志位 = 1，Z条件标志位 = 1

   右移前的最低位送入C位

3. **ASR：算术右移**

   **左端用第31位的值来填充**

   例如：MOVS R0，R1，ASR #1

   指令执行前：R0 = 0x00000000，R1 = 0x80000001

   指令执行后：R0 = 0xC0000000，R1 = 0x80000001，C条件标志位 = 1，N条件标志 = 1 

   右移前的最低位送入C位

4. **ROR：循环右移**

   **左端用右端移出来的位来填充**

   例如：MOVS R0，R1，ROR #1

   指令执行前：R0 = 0x00000000，R1 = 0x40000001

   指令执行后：R0 = 0xA0000000，R1 = 0x40000001，C条件标志位 = 1，N条件标志位 = 1 

   右移前的最低位同时送入C位和左端最高位

5. **RRX：带扩展的循环右移**

   **右移时32位数据和C标志位共33数据组成一个循环往右移一次，C标志位移入最高位，最低位移入C位**

*总结：对于位移指令LSL、LSR、ASR、RRX来说，如果指令中有**S**选项时位移结果将影响CPSR中条件标志位的值*

##### 4.4 逻辑运算指令

1. **AND逻辑与运算指令**

   将两个操作数进行按位**与**运算，**S**选项决定指令的操作是否影响**CPSR**中条件标志位的值，当有**S**选项的时，指令的结果影响**CPSR**中的**N**和**Z**，在计算第*[2]*操作的时候，影响**C**，不影响**Z**

2. **ORR逻辑或运算指令**

   将两个操作数进行按位**或**运算，**S**选项决定指令的操作是否影响**CPSR**中条件标志位的值，当有**S**选项的时，指令的结果影响**CPSR**中的**N**和**Z**，在计算第*[2]*操作的时候，影响**C**，不影响**Z**

3. **EOR逻辑异或运算指令**

   将两个操作数进行按位**异或**运算，**S**选项决定指令的操作是否影响**CPSR**中条件标志位的值，当有**S**选项的时，指令的结果影响**CPSR**中的**N**和**Z**，在计算第*[2]*操作的时候，影响**C**，不影响**Z**，**该指令常用于反转操作数*[1]*的某些位**

4. **BIC位清除运算指令**

   将两个操作数进行按位**位清除**运算，**S**选项决定指令的操作是否影响**CPSR**中条件标志位的值，当有**S**选项的时，指令的结果影响**CPSR**中的**N**和**Z**，在计算第*[2]*操作的时候，影响**C**，不影响**Z**

##### 4.4 比较指令

比较指令根据结果更新**CPSR**中的条件标志位，在设置标志位后，其他指令可以通过条件执行来改变程序的执行顺序；对于比较指令，**不需要使用S后缀就可以改变条件标志位的值**

1. **CMP指令**

   该指令实质上是进行一次**减法**运算但不保存结果，并更新**CPSR**中的条件标志位，后面的指令可以根据条件标志位来决定是否执行

2. **CMN反值比较指令**

   该指令实质上是进行一次**加法**运算但不保存结果，并更新**CPSR**中的条件标志位，后面的指令可以根据条件标志位来决定是否执行

3. **TST位测试指令**

   该指令实质上是进行一次**按位与**运算但不保存结果，并更新**CPSR**中的条件标志位，后面的指令可以根据条件标志位来决定是否执行

4. **TEQ相等测试指令**

   该指令实质上是进行一次**异或**运算但不保存结果，并更新**CPSR**中的条件标志位，后面的指令可以根据条件标志位来决定是否执行

##### 4.5 数据加载与存储指令

Load指令用于把内存中的数据装载到寄存器中，Store指令用于把寄存器的数据装载到内存中

###### 4.5.1 指令的基本格式

opcode{<cond>} Rd，addr

addr为存储器的**地址表达式**，addr有以下几种表达形式：

1. 立即数

   LDR R5，[R6，#0x08]；	

2. 寄存器

   LDR R5，[R6，R3]；

3. 寄存器位移

   LDR R5，[R6，R2，LSL #6]

4. 标号

   LDR R5，START；	#将START 标号地址上的内容放入R5

   **这种方法中，程序计数器PC是隐含的基地址寄存器，偏移量是标号所在的地址和PC之间的差值**

###### 4.5.2 地址索引

1. 前索引

   LDR R5，[R6，#0x08]

2. 自动索引

   LDR R5，[R6，#0x08]！

3. 后索引

   LDR R5，[R6]，#0x08

###### 4.5.3 单寄存器加载与存储指令

1. LDR/STR	             字数据加载/存储

   LDR指令用于从内存中将一个32位的字读取到指令中的目标寄存器中

   STR指令用于将一个32位的字数据写入到指令中指定的内存单元中

2. LDRB/STRB	        字节数据加载/存储

   LDRB指令用于从内存中将一个8位的字节数据读取到指令中的目标寄存器中，并将寄存器的高24位清零

   STRB指令用于将一个8位的字节数据写入到指令中指定的内存单元中，该字节数据为指令中存放源操作数的寄存器的低8位

3. LDRH/STRH            半字数据加载/存储

   LDRH指令用于从内存中将一个16位的半字数据读取到指令中的目标寄存器中，并将寄存器的高16位清零

   STRH指令用于将一个16位的字节数据写入到指令中指定的内存单元中，该字节数据为指令中存放源操作数的寄存器的低16位

4. LDRSB/STRSB        有符号字节数据加载/存储

   LDRB指令用于从内存中将一个8位的字节数据读取到指令中的目标寄存器中，并将寄存器的高24位设置成该字节数据的符号位的值

   

5. LDRSH/STRSH        有符号半字数据加载/存储

   LDRB指令用于从内存中将一个16位的半字数据读取到指令中的目标寄存器中，并将寄存器的高16位设置成该字节数据的符号位的值

###### 4.5.4 多寄存器加载与存储指令

汇编格式：LDM/STM{<cond>}{<type>} Rn{!}，<regs>{^}

LDM指令用于从基地址寄存器所指示的一片连续的内存空间中读取数据到寄存器列表所指示的多个寄存器中，内存单元的起始地址为基地址寄存器Rn的值，多个寄存器由寄存器列表regs表示；该指令一般用于多个寄存器数据的出栈操作

STM指令用于将寄存器列表所指示的多个寄存器中的值存入到由基地址所指示的一片连续的内存空间中，内存单元的起始地址为基地址寄存器Rn的值，多个寄存器由寄存器列表regs表示；该指令一般用于多个寄存器数据的入栈操作

指令中的type有以下几种情况：

1. IA每次传送后地址值加

   STMIA R0!，{R1-R4}

   <img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200510224711990.png" alt="image-20200510224711990" style="zoom:50%;" />

2. IB每次传送前地址值加

   STMIB R0!，{R1-R4}

   <img src="https://raw.githubusercontent.com/Thomas-zjw/git-doc/master/image/image-20200510225037326.png" alt="image-20200510225037326" style="zoom:50%;" />

3. DA每次传送后地址值减

   STMDA R0!，{R1-R4}

   <img src="C:\Users\XM\AppData\Roaming\Typora\typora-user-images\image-20200510225157010.png" alt="image-20200510225157010" style="zoom:50%;" />

4. DB每次传送前地址值减

   STMDB R0!，{R1-R4}

   <img src="C:\Users\XM\AppData\Roaming\Typora\typora-user-images\image-20200510225624439.png" alt="image-20200510225624439" style="zoom:50%;" />

*注：在递增（IA，IB）方式下，寄存器的顺序是R1->R4；在递减（DA，DB）方式下，寄存器的顺序是R4->R1；*
*约定：编号低的寄存器在存储数据或加载数据的时候对应内存的低地址*

用于**堆栈操作**时有 以下几种情况：

1. FD满递减堆栈
2. ED空递减堆栈
3. FA满递增堆栈
4. EA空递增堆栈

**{^}可选后缀，当指令为LDM且寄存器列表中包含R15时，该后缀表示：除了正常的数据传输外，还将SPSR复制到CPSR，同时该后缀还表示传入或传出的是用户模式下的寄存器，而不是当前模式下的寄存器**

##### 4.6 堆栈操作

堆栈操作包括

1. 建栈
   LDR SP，=0x090010

   SP指向0x090010，SP始终指向栈顶；此时，为空栈，栈底和栈顶重合

2. 进栈

   首先需要确定栈在内存中是向上生长还是向下生长，向上生长称为递增，向下生长称为递减；

   满堆栈是指SP指向堆栈的最后一个数据的位置；空堆栈是指SP指向堆栈的第一个空位置

   **在ATPCS中，堆栈被定义为满递减栈，因此LDMFD和STMFD指令分别用来支持出栈和入栈操作**

3. 出栈
   STMFD相当于指令STMDB；LDMFD相当于指令LDMIA

##### 4.7 分支指令

ARM中有两种方法实现程序流程的跳转：

1. 使用分支指令
2. 直接向PC写入目标地址值

###### 4.7.1 分支指令B

B{<cond>} Label
一旦遇到指令B，立即跳转到给定的目标地址，即PC = Label

###### 4.7.2 带返回的分支指令BL

BL{<cond>} Label
在跳转之前，将PC的当前内容保存到LR中，因此可以通过将LR中的内容重新加载到PC中，返回到跳转指令之后的那个指令处执行

###### 4.7.3 带状态切换的分支指令BX

###### 4.7.4 带返回和状态切换的分支指令BXL

##### 4.8 程序状态寄存器访问指令

访问CPSR和SPSR需要使用MRS**(读状态寄存器指令)**和**MSR(写状态寄存器指令)**指令

**MRS**指令用于将程序状态寄存器的内容传送到通用寄存器中
汇编指令格式：MRS{<cond>}<Rd>，<CPSR|SPSR> #Rd不允许为R15

MSR指令用于将通用寄存器的内容传送到程序状态寄存器中
汇编指令格式：MSR{<cond>}<CPSR|SPSR>_<fields>，<Rm|#immed>
<fields>可以用于设置程序状态寄存器中需要操作的位，程序状态寄存器可以分为4个域：

<img src="C:\Users\XM\AppData\Roaming\Typora\typora-user-images\image-20200523173247606.png" alt="image-20200523173247606" style="zoom:50%;" />

- 位[31:24]为条件标志位，用 ***f*** 表示
- 位[23:16]为状态位，用 ***s*** 表示
- 位[15: 8]为扩展位，用 ***x*** 表示
- 位[7:0]为控制位，用 ***c*** 表示

例如：MSR CPSR_c，R0

### 4. 协处理器CP15

CP15可以包含16个(0~15)个32位的寄存器

#### 4.1 访问CP15协处理器的指令

1. MCR指令：ARM寄存器中的数据传送到协处理器寄存器中
   汇编指令格式：
   MCR{<cond>} p15, 0, <Rd>, <CRn>, <CRm>{, <opcode_2>} 
   MCR2 p15, 0, <Rd>, <CRn>, <CRm>{, <opcode_2>} 

   - <cond>为指令执行的条件码，当忽略<cond>时，表示无条件执行；在MCR2中，条件码为0111，指令无条件执行
   - 0为协处理器将执行的操作的条件码，对于协处理器来说永远为0
   - <Rd>为ARM的寄存器，<Rd>不能为R15
   - <CRn>、<CRm>协处理器的寄存器编号，C0 ~ C15，当指令中不需要<CRm>时，将<CRm>设置为C0
   - 协处理器将执行的操作数

2. MRC指令：将协处理器中的寄存器的数值传送到ARM寄存器中
   汇编指令格式：

   MRC{<cond>} p15, 0, <Rd>, <CRn>, <CRm>{, <opcode_2>} 
   MRC2 p15, 0, <Rd>, <CRn>, <CRm>{, <opcode_2>} 

**MCR指令和MRC指令只能在处理器模式是系统模式的时候使用，在用户模式下使用MCR和MRC指令会触发未定义指令的异常**

#### 4.2 CP15中的寄存器介绍

CP15有16个32位的寄存器，这里主要介绍C0和C1寄存器

<img src="C:\Users\XM\AppData\Roaming\Typora\typora-user-images\image-20200528215233374.png" alt="image-20200528215233374" style="zoom:50%;" />

1. 寄存器C0

   C0是一个只读寄存器，存放ARM相关的标识符；当在MRC指令中，指定不同的opcode_2时，读取到不同的标识符

   <img src="C:\Users\XM\AppData\Roaming\Typora\typora-user-images\image-20200528215521717.png" alt="image-20200528215521717" style="zoom:60%;" />

   - 标识符寄存器
     读取CP15中主标识符的指令如下：
     MRC P15，0，R0，C0，C0，0

     主标识符

2. 寄存器C1

   cache类型标识符寄存器

   

### 5. MMU

















